Тестовое задание по реализации приложения по трекингу автомобилей и поиска ближайших автомобилей к точке.
Пример пера v2

Почему так сложно (оправдания за сложный код):
======
При начальном проектировании приложения в мыслях зародилась большая мысль, что приложение должно работать _очень_ быстро
Справляться с высокими нагрузками, быть отзывчивым и.т.д
Еще код должен быть надежным (т.е должно быть хорошее покрытие кода тестами)

Во время реализации выяснилось, что делать производительно изначально нереально (что логично), да и общая архитектура была не особо ясна
Поэтому код поделился на составляющие, которые можно обособленно тестировать, замерять скорость, заменять, сравнивать разные подходы
Например класс Map лежит отдельно от db чтобы его можно было заменить.
В Map хранится интерфейс для db, наследовать ли RtreeMap от нее, или оставить код по выбору конкретной реализации в классе
Map - решено еще не было, так что там еще неразбериха.

Аналогично в аггрегаторе. В базовый класс вынесен интерфейс работы с db так, что при реализации другого протокола приема данных
нужно просто прсоеденить его к базовому классу. Об остальном приложении знать ничего не нужно. Также в базовый класс хорошо
легла валидация

Класс Car по-началу был простым контейнером для данных (как и Point). Потом в него были перенесены все функции по передвижению.
За аналогию взял ОРМ. Из базы (db) мы запрашиваем автомобиль (Car) и уже работаем непосредственно с ним. Получается мы
разделяем контейнер с автомобилями и сам автомобиль. (можно было пойти дальше и в объекте Car сделать метод get,
но это стало бы слишком запутанным. Плюсом еще можно в тестах создать фейковый объект db и тестировать Car вместе с ним
(т.е провести юнит-тестирование Car и DB в отдельности, а потом функциональное тестирвоание их вместе))

По ТЗ нужно было обеспечить максимально быструю доставку данных о перемещениях клиентам. Был выбран WebSocket, как самая топорная
реализация и набросаны GUI, чтобы было удобно отлаживать.
Т.к я боялся за каждую часть приложения, watcher я сделал также модульным, чтобы можно было использовать разные протоколы и реализации
(вышло так, что их можно использовать одновременно, как и aggregator тоже может быть не один). Для оповещения о событиях автомобиля
было решено использовать события. Они хорошо удовлетворяют задаче (клиентов может быть много, они могут отключаться/подключаться)
Также поверх событий можно легко реализовывать тесты.


В общем, я либо черезчур преувеличил ТЗ, ожидая от него подвоха во всем (необходимость быстро повысить производительность,
необходимость покрыть все тестами, архитектурно интегрировать его с другими компонентами (например, не машины будут сообщать
местоположение, а наш краулер будет опрашивать сервера хранения этих данных)), либо просто плохо справился с заданием :)
Не пинайте сильно, если сюда загляните
======


ТЗ:
======
С использованием фреймворка Twisted написать сервер, хранящий информацию о местоположении автомобилей на карте, который:

1. принимает информацию от устройств водителей о местоположении авто
(пусть конкретная машина задаётся идентификатором и координатами широта-долгота)
2. предоставляет канал, позволяющий с минимальной задержкой получать уведомления о перемещении отдельной машины
3. позволяет по запросу получить N автомобилей, ближайших к указанной точке
======

Исходный код лежит в src, запускается через файл main.py
Настройки лежат в файле settings.py

В директории tester лежит реализация клиента (автомобиля), запускается через файл main.py
Настройки лежат в файле settings.py

Файлы settings.py документированы.

Веб-интерфейс клиента::
======
После запуска по адресу http://127.0.0.1:8081/ будет доступен список всех автомобилей.
Запросом http://127.0.0.1:8081/get_near?latitude=56.916092&longitude=60.593254&json=1&max_cars=5
можно получить ближайшие автомобили, где
- latitude и longitude - координаты
- json - флаг, что отдавать данные нужно в формате json
- max_cars - кол-во автомобилей

При отображении списка автомобилей в html каждый автомобиль будет предоставляться ссылкой,
по которой будет страница с кортой, на которой в реальном времени будет изменяться положение автомобиля
А при клике по карте будет производиться поиск ближайших к ней автомобилей
======

Протокол для автомобиля:
======
Сначала необходимо пройти по ссылке http://127.0.0.1:8080/login
после которой автомобиль зарегистрируется в базе и ему вернется идентификатор сессии в куках

По ссылке http://127.0.0.1:8080/logout автомобиль может разлогиниться (клиента, который следит за
автомобилем уведомит, что автомобиль закрыл соединение)

По ссылке http://127.0.0.1:8080/data?latitude=56.835567&longitude=60.590891 передаются текущие координаты автомобиля
======

cd ./src; ./run_tests.sh    - запуск тестов